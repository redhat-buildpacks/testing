---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildpacks-phases
  labels:
    app.kubernetes.io/version: "0.3"
  annotations:
    tekton.dev/categories: Image Build, Security
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/tags: image-build
    tekton.dev/displayName: "Buildpacks (phases)"
    tekton.dev/platforms: "linux/amd64"
spec:
  description: >-
    The Buildpacks-Phases task builds source into a container image and pushes it to
    a registry, using Cloud Native Buildpacks. This task separately calls the aspects of the
    Cloud Native Buildpacks lifecycle, to provide increased security via container isolation.

  workspaces:
    - name: source
      description: Directory where application source is located.
    - name: cache
      description: Directory where cache is stored (when no cache image is provided).
      optional: true
    - name: shared
      description: Directory where information is shared between Buildpack steps
      optional: true

  params:
    - name: CNB_BUILDER_IMAGE
      description: The image on which builds will run (must include lifecycle and compatible buildpacks).
    - name: CNB_BUILD_IMAGE
      description: Reference to the current build image in an OCI registry (if used <kaniko-dir> must be provided)
    - name: CNB_LIFECYCLE_IMAGE
      description: The image to use when executing sensitive phases.
      default: docker.io/buildpacksio/lifecycle:0.10.2@sha256:1bf8d3fc41d2fdf0ee4abdad50038ab8902ef58c74f5bcfc432c26767d889ed0
    - name: CNB_EXPERIMENTAL_MODE
      description: Environment variable to control ALL experimental features by the platform.
      default: "warn"
    - name: CNB_LOG_LEVEL
      description: Logging level
      default: "info"
    - name: APP_IMAGE
      description: The name of where to store the app image.
    - name: CNB_RUN_IMAGE
      description: Reference to a run image to use.
      default: "paketobuildpacks/run-jammy-tiny:latest"
    - name: CACHE_IMAGE
      description: The name of the persistent app cache image (if no cache workspace is provided).
      default: ""
    - name: PROCESS_TYPE
      description: The default process type to set on the image.
      default: ""
    - name: SOURCE_SUBPATH
      description: A subpath within the `source` input where the source to build is located.
      default: ""
    - name: ENV_VARS
      type: array
      description: Environment variables to set during _build-time_.
      default: []
    - name: PLATFORM_DIR
      description: The name of the platform directory.
      default: empty-dir
    - name: USER_ID
      description: The user ID of the builder image user.
      default: "1001"
    - name: GROUP_ID
      description: The group ID of the builder image user.
      default: "1000"
    - name: USER_HOME
      description: Absolute path to the user's home directory.
      default: /tekton/home
  results:
    - name: APP_IMAGE_DIGEST
      description: The digest of the built `APP_IMAGE`.
    - name: IMAGE_URL
      description: The URL of the built `APP_IMAGE`. Used by RHTAP.
    - name: IMAGE_DIGEST
      description: The digest of the built `APP_IMAGE`. Used by RHTAP.
  stepTemplate:
    env:
      - name: CNB_PLATFORM_API
        value: "0.12"
      - name: CNB_EXPERIMENTAL_MODE
        value: $(params.CNB_EXPERIMENTAL_MODE)
      - name: HOME
        value: $(params.USER_HOME)

  steps:
    - name: check-image-builder-extension
      image: quay.io/ch007m/extended-skopeo
      script: |
        #!/usr/bin/env bash
        set -e
        
        BUILDER_IMAGE=quay.io/ch007m/nodejs-ubi-extension-builder
        EXT_LABEL_1="io.buildpacks.extension.layers"
        EXT_LABEL_2="io.buildpacks.buildpack.order-extensions"
        
        IMG_MANIFEST=$(skopeo inspect "docker://$BUILDER_IMAGE")
        
        if echo $IMG_MANIFEST | jq -e '.Labels | has("'${EXT_LABEL_1}'") and has("'${EXT_LABEL_2}'")' > /dev/null; then
          echo "Image: $IMAGE_NAME has the specified label: $EXT_LABEL_1 and $EXT_LABEL_2."
        else
          echo "Image does not have the specified extensions label !"
        fi
        
        CNB_USER_ID=$(echo $IMG_MANIFEST | jq -r '.Env' | jq -r '.[] | select(test("^CNB_USER_ID="))'  | cut -d '=' -f 2)
        CNB_GROUP_ID=$(echo $IMG_MANIFEST | jq -r '.Env' | jq -r '.[] | select(test("^CNB_GROUP_ID="))' | cut -d '=' -f 2)
        
        echo "CNB_USER_ID: ${CNB_USER_ID}"
        echo "CNB_GROUP_ID: ${CNB_GROUP_ID}"
        
        echo $CNB_USER_ID  > $(workspaces.shared.path)/uid
        echo $CNB_GROUP_ID > $(workspaces.shared.path)/gid

    - name: prepare
      image: quay.io/swsmirror/bash
      args:
        - "--env-vars"
        - "$(params.ENV_VARS[*])"
      script: |
        #!/usr/bin/env bash
        set -e
        
        echo "Extension UID: $(workspaces.shared.path)/uid"
        echo "Extension GID: $(workspaces.shared.path)/gid"

        # TODO: To be reviewed and aligned with Shipwright ClusterBuildStrategy
        if [[ "$(workspaces.cache.bound)" == "true" ]]; then
          echo "> Setting permissions on '$(workspaces.cache.path)'..."
          chown -R "$(params.USER_ID):$(params.GROUP_ID)" "$(workspaces.cache.path)"
        fi
        
        echo "Creating .docker folder"
        mkdir -p "/tekton/home/.docker"

        for path in "/tekton/home" "/tekton/home/.docker" "/layers" "$(workspaces.source.path)"; do
          echo "> Setting permissions on '$path'..."
          chown -R "$(params.USER_ID):$(params.GROUP_ID)" "$path"
        done

        echo "> Parsing additional configuration..."
        parsing_flag=""
        envs=()
        for arg in "$@"; do
            if [[ "$arg" == "--env-vars" ]]; then
                echo "-> Parsing env variables..."
                parsing_flag="env-vars"
            elif [[ "$parsing_flag" == "env-vars" ]]; then
                envs+=("$arg")
            fi
        done

        echo "> Processing any environment variables..."
        ENV_DIR="/platform/env"

        echo "--> Creating 'env' directory: $ENV_DIR"
        mkdir -p "$ENV_DIR"

        for env in "${envs[@]}"; do
            IFS='=' read -r key value string <<< "$env"
            if [[ "$key" != "" && "$value" != "" ]]; then
                path="${ENV_DIR}/${key}"
                echo "--> Writing ${path}..."
                echo -n "$value" > "$path"
            fi
        done
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.PLATFORM_DIR)
          mountPath: /platform

    - name: analyze
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/analyzer"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-layers=/layers"
        - "-run-image=$(params.CNB_RUN_IMAGE)"
        - "-cache-image=$(params.CACHE_IMAGE)"
        - "-uid=$(params.USER_ID)"
        - "-gid=$(params.GROUP_ID)"
        - "$(params.APP_IMAGE)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers

    - name: detect
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/detector"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-app=$(workspaces.source.path)/$(params.SOURCE_SUBPATH)"
        - "-group=/layers/group.toml"
        - "-plan=/layers/plan.toml"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.PLATFORM_DIR)
          mountPath: /platform
        - name: empty-dir
          mountPath: /tekton/home

    - name: restore
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/restorer"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-build-image=$(params.CNB_BUILD_IMAGE)"
        - "-group=/layers/group.toml"
        - "-layers=/layers"
        - "-cache-dir=$(workspaces.cache.path)"
        - "-cache-image=$(params.CACHE_IMAGE)"
        - "-uid=$(params.USER_ID)"
        - "-gid=$(params.GROUP_ID)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: kaniko-dir
          mountPath: /kaniko

    - name: extender
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/extender"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-generated=/layers/generated"
        - "-uid=$(params.USER_ID)"
        - "-gid=$(params.GROUP_ID)"
      securityContext:
        runAsUser: 0
        runAsGroup: 0
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: kaniko-dir
          mountPath: /kaniko
        - name: empty-dir
          mountPath: /tekton/home

    - name: build
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/builder"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-app=$(workspaces.source.path)/$(params.SOURCE_SUBPATH)"
        - "-layers=/layers"
        - "-group=/layers/group.toml"
        - "-plan=/layers/plan.toml"
        - "-uid=$(params.USER_ID)"
        - "-gid=$(params.GROUP_ID)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers
        - name: $(params.PLATFORM_DIR)
          mountPath: /platform
        - name: empty-dir
          mountPath: /tekton/home

    - name: export
      image: $(params.CNB_BUILDER_IMAGE)
      imagePullPolicy: Always
      command: ["/cnb/lifecycle/exporter"]
      args:
        - "-log-level=$(params.CNB_LOG_LEVEL)"
        - "-app=$(workspaces.source.path)/$(params.SOURCE_SUBPATH)"
        - "-layers=/layers"
        - "-group=/layers/group.toml"
        - "-cache-dir=$(workspaces.cache.path)"
        - "-cache-image=$(params.CACHE_IMAGE)"
        - "-report=/layers/report.toml"
        - "-process-type=$(params.PROCESS_TYPE)"
        - "-uid=$(params.USER_ID)"
        - "-gid=$(params.GROUP_ID)"
        - "$(params.APP_IMAGE)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers

    - name: results
      image: quay.io/swsmirror/bash
      script: |
        #!/usr/bin/env bash
        set -e
        cat /layers/report.toml | grep "digest" | cut -d'"' -f2 | cut -d'"' -f2 | tr -d '\n' | tee $(results.APP_IMAGE_DIGEST.path)
        cat $(results.APP_IMAGE_DIGEST.path) | tee "$(results.IMAGE_DIGEST.path)"
        
        echo -n "$(params.APP_IMAGE)" | tee "$(results.IMAGE_URL.path)"
      volumeMounts:
        - name: layers-dir
          mountPath: /layers

  volumes:
    - name: empty-dir
      emptyDir: {}
    - name: layers-dir
      emptyDir: {}
    - name: kaniko-dir
      emptyDir: {}